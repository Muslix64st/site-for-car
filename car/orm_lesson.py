"""Справочное руководство ORM
выписываем основные команды"""

""" 
Car.objects.all()-------------выбирает все записи из таблицы сортировка такая же как и в классе мета
Car.objects.all()[:5]---------Срез берёт первые 5 записей
Car.objects.all()[3:8]--------Срез с 3 по 8

Car.objects.order_by('pk')----сортировка по PK
Car.objects.order_by('title')-сортировка по имени или можно ставить любое поле из таблицы
Car.objects.all().reverse()---Выведет в обратном порядке
Car.objects.get(pk=2) одна запись у которой PK=2 возвращает ЭКЗЕМПЛЯР


w = Car.objects.get(pk=1) создаём переменную в которой нам доступны все поля что в модели

w.cat
        ссылка на экземпляр класса categoty потому что cat связанна c категорией 
        в которой определён магический метод __str__ который возвращает имя категории а если это так томы можем достучаться 
        к любому полю связанной категории

w.cat.name 
            обращаемся к полю name категории category которая связанна с CAT

c = Category.objects.get(pk=1) читаем первую запись в таблице  

c.car_set.all() через переменную С мы обращаемся в модели car и выбираем все посты связанные с PK=1 yf 
                на примере можно увидеть что выдаст все записи мини автомобили
аналогично можно обратится к этому параметру если в связанной категории указан параметр
related_name='имя параметра' тогда можно обращаться через него c.'имя параметра'.all()

______________________________________  ЛУКАПЫ  ________________________________________________________

car.objects.filter(pk__gt=2) выбирает все записи у которых PK больше или равен 2 возвращает коллекцию queriset
Car.objects.filter(pk__lte=2) выведет все записи у которых PK меньше или равен 2 возвращает коллекцию queriset

Car.objects.filter(title__contains='м') возвращает все записи в заголовках которых встречается буква М 
                                        но можно указать и слово и слог
Car.objects.filter(title__icontains='М') делает всё то же самое только без учёта регистра 
                                        плохо работает или не работает если указан верхний регистр
                                        в SQLite потому что она не поддерживает верхний регистр не ASCI символов
                                        ну а с латинскими происходит регитсронезависимый поиск
Car.objects.filter(pk__in=[2,5,12,14])  позволяет указывать через список выбираемые записи по значениям можно указывать вборку
                                        по любому из доступных полей
                                        
Car.objects.filter(pk__in=[2,5,12,14], is_published=True) вторым и последующим (можно несколько)
                                                          параметром можно указать дополнительное условие, также общее условие 
                                                          будет истино если истино каждое из условий сдесь работает AND
                                                        
Car.objects.filter(cat__in=[2,3]) здесь уже происходит обращение к связанной записи Category и выдаст нам все записи
                                  связанные с выбранными критериями (тоесть ВСЕ записи их может быть много тут можно
                                  задавать второй параметр фильтрации записи)
cats = Category.objects.all()  выбираем все записи и передаём в переменную
Car.objects.filter(cat__in=cats) теперь через фильтр выбираем все связанные записи в модели CAR все связанные записи которые есть
                                 в CATEGORY
                                 
-------------------------------------------------------------------------------------------------------------------------                                 
from django.db.models import Q  импортировать класс Q для работы с логическими операторами

~   логическое НЕ (приоритет 1)
&   логическое И  (приоритет 2)
|   логическое НЕ (приоритет 3)     


Car.objects.filter(pk__lt=5, cat_id=2) выбираем все записи у которых первичный ключ меньше или равен 5  pk__lt=5
                                       и те записи которые принадлежат ко второй категории  cat_id=2

Car.objects.filter(Q(pk__lt=5) | Q(cat_id=2)) выполняется логический оператор ИЛИ 
                                             (Q(pk__lt=5) или Q(cat_id=2))

Car.objects.filter(Q(pk__lt=5) & Q(cat_id=2)) логический оператор И только если 2 условия истины
        тоже самое что  
Car.objects.filter(pk__lt=5, cat_id=2)


Car.objects.filter(~Q(pk__lt=5) & Q(cat_id=2)) тут работаем от обратного выборка происходит всех записей при PK>5 
                                               И cat_id=2

Car.objects.filter(~Q(pk__lt=5) | Q(cat_id=2)) выборка происходит всех записей при PK>5 или (cat_id=2)   
_______________________________________________________________________________________________________________________________

first()
last()


Car.objects.first()   возвратит первую запись в базе данных      
Car.objects.order_by('pk')first()  сперва сортируем по какому то полю потом уже после сортировки берём первую запись
Car.objects.order_by('-pk')first()  сперва сортируем по какому то полю в обратном порядке 
                                    потом уже после сортировки берём первую запись
Car.objects.last() берёт последнюю запись в БД
Car.objects.order_by('pk')last()  сортирует и берёт последнюю запись

___________________________________________________________________________________________________________________________________
latest()
earliest()

Если в таблице присутствуют поля привязанные ко времени создания или обновления!!!!!

Car.objects.latest('time_update') в этом случае выдаст запись которая была добавлена самой первой
Car.objects.earliest('time_update') которая была добавлена самой последней

________________________________________________________________________________________________________________________

get_previous
get_next

plot = Car.objects.get(pk=7) делаем выборку из таблицы по заданному условию (можно по разным полям) 

plot.get_previous_by_time_update() берёт предыдущую запись относительно времени обновления 
plot.get_previous_by_time_create() берёт предыдущую запись относительно времени создания
plot.get_next_by_time_update()     берёт следующую запись относительно времени обновления
plot.get_next_by_time_create()     берёт следующую запись относительно времени создания

plot.get_next_by_time_create(pk=10) получить следующую запись но только такую у которой pk больше 10
                                    можно также прописывать и более сложные условия сортировки или представления
                                    
______________________________________________________________________________________________________________________

exists() - проверка существования записи
count() - получения числа записей

cs = Category.objects.get(pk=2) берём записи из категории РК = 2
cs.car_set.exists() проверяем пустая категория или нет
cs.car_set.count() смотрим сколько записей привязано ко второй категории РК = 2

Car.objects.filer(pk__gt=4).count() выбрать все записи РК=>4 и вывести количество этих записей
                                    
______________________ Обращение к полю модели через атрибут___________________________________________________э

Car.objects.filter(cat__slug='mini-avtomobili') обращаемся через модель CAR и её полю CAT которая связанна с другой
                                                моделью CATEGORY и через неё мы обращаемся к атрибуту slug 
                                                равный тому что указано в ковычках. Результатом будет все объекты CAR
                                                которые связанны с это категорией 




__________________Обработка данных связанных таблиц
From django.db import connection Импорт модуля
connection.queries просмотр запросов
"""